// Generated by CoffeeScript 1.6.3
(function() {
  var check_validity, generate_groupings, groupings, input_data, unpack,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  generate_groupings = function(num_students, num_groups) {
    /*
    	Generates all possible groupings of num_students students 
    	into int num_groups groups. 
    
    	Parameters
    	__________
    
    	num_students : type int 
    		number of students
    
    	num_groups : type int 
    		number of groups
    
    	Returns
    	_______ 
    
    	groups : type list[list]
    		
    		list of lists, with each element representing a allocation of students
    		into groups e.g. 
    
    		groups = [0, 2, 1]
    
    		means student 0 is in group 0, student 1 in group 2, student 2 in group 1.
    
    	Raises
    	______ 
    
    	ValueError : if number of groups exceedes number of students
    */

    var group, group_index, groups, new_group, new_groups, student_index, x, _i, _j, _k, _len;
    if (num_students < num_groups) {
      console.log('number of groups must be less than or equal to number of students');
      return;
    }
    groups = (function() {
      var _i, _results;
      _results = [];
      for (x = _i = 1; 1 <= num_groups ? _i <= num_groups : _i >= num_groups; x = 1 <= num_groups ? ++_i : --_i) {
        _results.push([x]);
      }
      return _results;
    })();
    for (student_index = _i = 2; 2 <= num_students ? _i <= num_students : _i >= num_students; student_index = 2 <= num_students ? ++_i : --_i) {
      new_groups = [];
      for (_j = 0, _len = groups.length; _j < _len; _j++) {
        group = groups[_j];
        for (group_index = _k = 1; 1 <= num_groups ? _k <= num_groups : _k >= num_groups; group_index = 1 <= num_groups ? ++_k : --_k) {
          new_group = group.concat([group_index]);
          new_groups.push(new_group);
        }
      }
      groups = new_groups;
    }
    return groups;
  };

  check_validity = function(grouping, students, num_groups) {
    /*
    	Checks validity of one particular grouping of students against traits in students (dict).
    
    	Parameters
    	__________ 
    
    	grouping : type list[int]
    		grouping of len(grouping) students into groups
    
    	students : type list[dict]
    		list of dictionary (unpacked from json) of students with traits
    
    	Returns
    	_______ 
    
    	valid : type bool 
    		True if grouping is valid according to requirements.
    */

    var group, group_idx, i, num_noisy, num_understand, student1, student2, student_id, _, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1;
    for (group_idx = _i = 1; 1 <= num_groups ? _i <= num_groups : _i >= num_groups; group_idx = 1 <= num_groups ? ++_i : --_i) {
      group = (function() {
        var _j, _ref, _results;
        _results = [];
        for (student_id = _j = 0, _ref = grouping.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; student_id = 0 <= _ref ? ++_j : --_j) {
          if (grouping[student_id] === group_idx) {
            _results.push(student_id);
          }
        }
        return _results;
      })();
      num_noisy = 0;
      for (student_id = _j = 0, _len = group.length; _j < _len; student_id = ++_j) {
        _ = group[student_id];
        if (students[student_id]['noisy'] === true) {
          num_noisy = num_noisy + 1;
        }
      }
      if (num_noisy > 2) {
        return false;
      }
      num_understand = 0;
      for (i = _k = 0, _ref = group.length - 1; 0 <= _ref ? _k <= _ref : _k >= _ref; i = 0 <= _ref ? ++_k : --_k) {
        if (students[group[i]]['understands'] === true) {
          num_understand = num_understand + 1;
        }
      }
      if (num_understand < 1) {
        return false;
      }
      for (_l = 0, _len1 = group.length; _l < _len1; _l++) {
        student1 = group[_l];
        for (_m = 0, _len2 = group.length; _m < _len2; _m++) {
          student2 = group[_m];
          if (_ref1 = students[student1]['name'], __indexOf.call(students[student2]['fights_with'], _ref1) >= 0) {
            return false;
          }
        }
      }
    }
    return true;
  };

  unpack = function(group, students, num_groups) {
    /*
    	Unpacks a grouping expressed as a list into a list of lists of names (see below).
    
    	Parameters
    	__________
    
    	group : type list[int]
    		list of group indices, e.g. [1,0] student 0 to group 1, student 1 to group 0
    
    	Returns
    	_______ 
    
    	unpacked : type list[list[str]], e.g.
    		[
    			["Ava","Daniel","Jayden"],
    			["Madison","Noah","Mia"],
    			["Olivia","Brianna","Gavin","Kaylee"]
    		]
    */

    var group_id, i, idx, unpacked, _i, _len;
    unpacked = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 1; 1 <= num_groups ? _i <= num_groups : _i >= num_groups; i = 1 <= num_groups ? ++_i : --_i) {
        _results.push([]);
      }
      return _results;
    })();
    console.log(group);
    for (idx = _i = 0, _len = group.length; _i < _len; idx = ++_i) {
      group_id = group[idx];
      console.log(group_id);
      unpacked[group_id - 1].push(students[idx]['name']);
    }
    return unpacked;
  };

  input_data = require('./config.coffee').input_data;

  groupings = generate_groupings(input_data['students'].length, input_data['groups']);

  console.log(unpack(groupings[0], input_data['students'], input_data['groups']));

}).call(this);
